# MISSION: Интеграция фронтенда и бэкенда DEX Spread Monitor

## Общее описание
Данный документ содержит пошаговый план для интеграции существующего React/Next.js фронтенда с Python Flask бэкендом в полнофункциональное приложение для мониторинга спредов между различными DEX биржами.

## План интеграции

### 1. Настройка окружения

1. Обеспечить совместную работу фронтенда и бэкенда во время разработки:
   - Настроить proxy в Next.js для перенаправления API запросов на бэкенд
   - Или настроить CORS на бэкенде для принятия запросов с фронтенда

2. Настроить правильную структуру проекта:
   - Определить, как будут располагаться файлы фронтенда и бэкенда
   - Решить, будут ли они в одном репозитории или разных

### 2. Модификация бэкенда

1. Добавить поддержку CORS в Flask приложение:
   ```python
   from flask_cors import CORS
   app = Flask(__name__)
   CORS(app)
   ```

2. Обновить существующие API эндпоинты для полной совместимости с требованиями фронтенда:
   - Убедиться, что форматы данных соответствуют ожиданиям фронтенда
   - Добавить дополнительные параметры фильтрации, если необходимо

3. Добавить новые API эндпоинты, необходимые для фронтенда:
   - Эндпоинт для получения списка всех доступных торговых пар
   - Эндпоинт для получения исторических данных с различной гранулярностью
   - Эндпоинт для получения последних обновлений (или реализовать Server-Sent Events)

4. Реализовать механизм аутентификации (если необходимо):
   - Добавить базовую аутентификацию или JWT механизм
   - Защитить чувствительные эндпоинты

5. Оптимизировать запросы к базе данных:
   - Добавить индексы для ускорения запросов
   - Реализовать кэширование для частых запросов

### 3. Модификация фронтенда

1. Создать сервисный слой для работы с API:
   - Создать директорию `services/` с файлами для работы с каждым API эндпоинтом
   - Реализовать функции для вызова бэкенд API с правильными параметрами

2. Заменить моковые данные на реальные API вызовы:
   - В компоненте `SpreadChart`: заменить `generateMockData` на запрос к `/data`
   - В компоненте `SpreadTable`: заменить `generateMockSpreadData` на запрос к `/data`
   - В компоненте `LargestSpreadsTable`: заменить `generateMockLargestSpreads` на запрос к `/largest_spreads`

3. Доработать компоненты для динамического получения списков:
   - Обновить выпадающие списки бирж для динамической загрузки из API
   - Обновить выпадающие списки торговых пар для динамической загрузки из API

4. Добавить обработку состояний загрузки и ошибок:
   - Состояние загрузки: показывать скелетон или спиннер
   - Состояние ошибки: показывать сообщение об ошибке и предлагать повторить запрос

5. Реализовать автоматическое обновление данных:
   - Использовать SWR или React Query для автоматического обновления данных
   - Или реализовать периодические запросы через `useEffect` и `setInterval`

6. Доработать URL роутинг:
   - Обеспечить сохранение выбранных фильтров в URL параметрах
   - Реализовать загрузку начального состояния из URL параметров

### 4. Реализация функционала реального времени

1. Вариант №1 - Опрос:
   - Реализовать периодический опрос API с параметром `since` для получения только новых данных
   - Оптимизировать частоту опроса для баланса между актуальностью и нагрузкой

2. Вариант №2 - Server-Sent Events (рекомендуется):
   - Добавить в бэкенд Flask-SSE для отправки событий при новых данных
   - Реализовать на фронтенде обработчик SSE для получения обновлений в реальном времени

3. Вариант №3 - WebSocket:
   - Реализовать WebSocket сервер на бэкенде для отправки обновлений
   - Добавить WebSocket клиент на фронтенде для получения обновлений

### 5. Оптимизация производительности

1. Бэкенд:
   - Добавить кэширование запросов с использованием Redis или простого in-memory кэша
   - Оптимизировать SQL запросы, добавив необходимые индексы
   - Реализовать пагинацию для больших наборов данных

2. Фронтенд:
   - Реализовать виртуализацию списков для больших таблиц
   - Оптимизировать перерисовку компонентов с использованием React.memo, useMemo, useCallback
   - Реализовать lazy-loading для редко используемых компонентов

### 6. Тестирование

1. Тестирование API:
   - Проверить все API эндпоинты на соответствие ожидаемому формату данных
   - Проверить правильность обработки ошибок и граничных случаев

2. Тестирование интеграции:
   - Проверить полный цикл работы приложения: от получения данных до отображения на UI
   - Проверить корректность работы фильтрации, сортировки и пагинации

3. Тестирование производительности:
   - Проверить скорость загрузки данных при разных объемах
   - Проверить скорость отрисовки компонентов при больших наборах данных

### 7. Развертывание

1. Подготовка к продакшн:
   - Минимизировать и бандлить фронтенд (уже реализовано в Next.js)
   - Настроить кэширование статических ресурсов
   - Настроить GZIP сжатие для API ответов

2. Варианты развертывания:
   - Вариант 1: Один сервер для фронтенда и бэкенда (nginx + gunicorn/uwsgi)
   - Вариант 2: Раздельное развертывание (фронтенд на Vercel/Netlify, бэкенд на VPS/PaaS)

3. Настройка CI/CD:
   - Автоматизировать тестирование и деплой при изменениях в репозитории
   - Настроить мониторинг и логирование

### 8. Документация

1. Документация API:
   - Создать документацию всех API эндпоинтов с примерами запросов и ответов
   - Можно использовать Swagger/OpenAPI для автоматической генерации документации

2. Руководство по развертыванию:
   - Детальные инструкции по установке зависимостей и настройке окружения
   - Инструкции по развертыванию в продакшн

3. Руководство пользователя:
   - Описание функциональности приложения
   - Инструкции по использованию различных фичей

## Приоритеты задач

1. **Высокий приоритет** (необходимо для MVP):
   - Базовая интеграция бэкенда и фронтенда
   - Замена моковых данных на реальные API вызовы
   - Реализация периодического обновления данных

2. **Средний приоритет** (важно для полноценного использования):
   - Улучшение UX с обработкой состояний загрузки и ошибок
   - Оптимизация запросов и кэширование
   - Реализация функций реального времени

3. **Низкий приоритет** (улучшения для более зрелого продукта):
   - Расширенная аналитика и дополнительные метрики
   - Оптимизация производительности
   - Расширенные возможности фильтрации и визуализации данных 